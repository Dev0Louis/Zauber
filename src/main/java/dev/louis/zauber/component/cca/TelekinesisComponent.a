package dev.louis.zauber.component.cca;

import dev.louis.zauber.entity.BlockTelekinesisEntity;
import dev.louis.zauber.item.ZauberItems;
import net.minecraft.block.pattern.CachedBlockPosition;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.projectile.ProjectileUtil;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.EntityHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Vec3d;
import org.jetbrains.annotations.Nullable;
import org.ladysnake.cca.api.v3.component.sync.AutoSyncedComponent;
import org.ladysnake.cca.api.v3.component.tick.ServerTickingComponent;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.Optional;
import java.util.function.Predicate;

public class TelekinesisComponent implements AutoSyncedComponent, ServerTickingComponent {

    @Nullable
    private Entity telekinesedEntity;


    private static final int TARGETING_DISTANCE = 20;
    @Nullable
    private LivingEntity staffTargetedEntity;
    @Nullable
    private CachedBlockPosition staffTargetedBlock;


    private Optional<Entity> getTargetedEntity(int maxDistance) {
        Vec3d eyePos = this.getEyePos();
        Vec3d rotation = this.getRotationVec(1.0F).multiply(maxDistance);
        Vec3d start = eyePos.add(rotation);
        Box box = this.getBoundingBox().stretch(rotation).expand(1.0);
        int maxDistanceSquared = maxDistance * maxDistance;
        Predicate<Entity> predicate = entityx -> !entityx.isSpectator() && entityx.canHit();
        EntityHitResult entityHitResult = ProjectileUtil.raycast(this, eyePos, start, box, predicate, maxDistanceSquared);
        if (entityHitResult == null) {
            return Optional.empty();
        } else {
            return eyePos.squaredDistanceTo(entityHitResult.getPos()) > (double) maxDistanceSquared ? Optional.empty() : Optional.of(entityHitResult.getEntity());
        }
    }

    @Override
    public Optional<LivingEntity> getStaffTargetedEntity() {
        return Optional.ofNullable(staffTargetedEntity);
    }

    @Override
    public Optional<CachedBlockPosition> getStaffTargetedBlock() {
        return Optional.ofNullable(staffTargetedBlock);
    }

    @Override
    public void zauber$throwTelekinesis() {
        if(telekinesisEntity != null) {
            if (telekinesisEntity instanceof BlockTelekinesisEntity blockTelekinesisEntity) {
                blockTelekinesisEntity.throwBlock();
            } else {
                telekinesisEntity.setVelocity(telekinesisEntity.getPos().subtract(this.getPos()).multiply(0.2));
            }

            telekinesisEntity = null;
        }
    }

    @Override
    public Optional<Entity> zauber$getTelekinesisAffected() {
        return Optional.ofNullable(telekinesisEntity);
    }
    @Override
    public void readFromNbt(NbtCompound nbtCompound, RegistryWrapper.WrapperLookup wrapperLookup) {

    }

    @Override
    public void writeToNbt(NbtCompound nbtCompound, RegistryWrapper.WrapperLookup wrapperLookup) {

    }

    @Override
    public void serverTick() {
        staffTargetedEntity = null;
        staffTargetedBlock = null;
        if (this.getStackInHand(this.getActiveHand()).isOf(ZauberItems.STAFF)) {
            getTargetedEntity(TARGETING_DISTANCE)
                    .filter(LivingEntity.class::isInstance)
                    .map(LivingEntity.class::cast)
                    .ifPresent(entity -> staffTargetedEntity = entity);

            var rayCast = this.raycast(TARGETING_DISTANCE, 0, false);
            if (rayCast.getType() == HitResult.Type.BLOCK) {
                var world = this.getWorld();
                var pos = ((BlockHitResult) rayCast).getBlockPos();
                staffTargetedBlock = new CachedBlockPosition(world, pos, false);
            }
        }
    }
}
